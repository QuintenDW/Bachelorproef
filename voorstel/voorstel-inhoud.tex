%---------- Inleiding ---------------------------------------------------------

\section{Introductie}%
\label{sec:introductie}
In de afgelopen jaren zijn er heel wat nieuwe javascript runtime omgevingen geïntroduceerd. 
Echter worden weinig van deze nieuwe environments effectief gebruikt. 
Zo toont onderzoek van ~\textcite{Greif2022} aan dat 93.6\% van de 29888 bevraagden Node.js regulier gebruiken.
Dit tegenover de 4.3\% van de mensen die Bun regulier gebruiken.
Momenteel wordt Node.JS nog altijd als standaard gebruikt bij elk project. 
Er zijn echter nog tal van andere javaScript runtime omgevingen, zoals Bun, 
die in staat zijn om specifieke noden te vervullen waar Node.js niet aan kan voldoen.
Het doel van deze studie is te onderzoeken of Bun een correcte plaatsvervanger is voor Node.js 
binnen de ontwikkeling van web applicaties bij Codifly. 
Specifiek wordt de performantie en complexiteit tussen Node.js en Bun vergeleken alsook 
hun respectievelijke package manager en bundler. 
Hierbij wordt de performantie zowel vergeleken bij simpele applicaties als meer complexe applicaties.
In wat volgt wordt eerst een overzicht gegeven van de actuele ontwikkelingen binnen het
onderzoeksdomein aan de hand van een literatuurstudie, waarna de methodologie wordt besproken.
Ten laatste worden de resultaten van de vergelijking alsook de conclusie besproken.


%---------- Stand van zaken ---------------------------------------------------

\section{State-of-the-art}%
\label{sec:state-of-the-art}
% Voor literatuurverwijzingen zijn er twee belangrijke commando's:
% \autocite{KEY} => (Auteur, jaartal) Gebruik dit als de naam van de auteur
%   geen onderdeel is van de zin.
% \textcite{KEY} => Auteur (jaartal)  Gebruik dit als de auteursnaam wel een
%   functie heeft in de zin (bv. ``Uit onderzoek door Doll & Hill (1954) bleek
%   ...'')
JavaScript vormt de basis voor zowel Node.js als Bun. 
JavaScript is een geïnterpreteerde programmeertaal dat vooral bekend is bij front-end web development voor web pagina's ~\autocite{Mozilla2023}.
Echter kan het ook buiten browser omgevingen gebruikt worden met behulp van javascript runtime omgevingen zoals Node.js en Bun ~\autocite{Mozilla2023}.
Zo een javascript runtime omgeving bestaat uit alle componenten om javascript correct te laten werken ~\autocite{Christopher}. 
Het bevat een JavaScript engine, WEB API's en een callback queue ~\autocite{Christopher}. 
Deze runtime zal dan JavaScript code omzetten in code die verstaanbaar is voor de computer.
De omgeving specificeert waar dit wordt gedaan, dit kan in een browser maar ook in andere omgevingen.
De afgelopen jaren is het aantal van deze soort omgevingen sterk toegenomen. 
De meest bekende en oudste is Node.js. 
Node.js is een server-side framework dat wordt gebruikt voor schaalbare applicaties te maken ~\autocite{Gackenheimer2013}.
In het boek van ~\textcite{Ali2013} wordt verteld hoe Node.js zich onderscheidt zich van andere platformen door het gebruikt van een event loop. 
Wanneer in Node.js een I/O operatie wordt verwerkt zal een gebeurtenis worden uitgezonden. 
De event loop zal continu kijken of er zo gebeurtenissen voorkomen, 
en wanneer dit zo is zal het deze plaatsen in de event wachtrij. 
De event loop zal dan deze wachtrij doorgaan en 1 per 1 de event handlers uitvoeren. 
Dit laat toe om I/O operaties asynchroon te maken.
De JavaScript code binnenin Node.js wordt uitgevoerd door de V8 JavaScript engine, 
dezelfde engine die toelaat om JavaScript uit te voeren in Chrome ~\autocite{Syed2014}.
Hierbij wordt gebruik gemaakt van een call stack en een heap. 
De call stack is de plaats waar de code wordt uitgevoerd,terwijl de heap de plaats is waar alle nodige objecten worden opgeslagen ~\autocite{Christopher}.
Doordat JavaScript files steeds groter werden, werd in 2009 CommonJS geïntroduceerd. 
Dit specificeert een simpele API om modules te declareren die werken buiten de browser ~\autocite{Osmani2012}.
Hierbij is een module een stuk herbruikbare code dat kan gebruikt worden in  andere code ~\autocite{Osmani2012}.
Node.js volgt de CommonJS module specificatie, waarbij elk bestand zijn eigen module vormt ~\autocite{Syed2014}.
Buiten zelf modules te schrijven, bestaan er ook modules die geschreven zijn door andere mensen. 
Deze zijn te vinden in de Node Package Manager (NPM) ~\autocite{Wittern2016}. 
Deze modules kunnen dan gebruikt worden door andere mensen in hun eigen project ~\autocite{Ali2013}.

Performantie is 1 van de belangrijkste zaken bij een server-side framework. Daarom is Node.js dankzij zijn 
event-gedreven I/O model een veelvoorkomende keuze als het gaat om server-side frameworks. 
Echter wil Bun dit veranderen door nog meer focus te leggen op snelheid en performantie. 
Om dit te bereiken maakt Bun gebruikt van JavaScriptCore in plaats van V8 JavaScript engine ~\autocite{McDonnel2023}.
Dit is de ingebouwde engine voor WebKit, een web browser engine die wordt gebruikt op macOS en IOS ~\autocite{Pizlo2020}.
Door het gebruik van de JavaScriptCore engine zou Bun 4 keer sneller kunnen opstarten dan Node.js ~\autocite{McDonnel2023}.
Bun bevat daarnaast ook een test runner,script runner en een Node.js compatibele package manager, die volgens ~\textcite{McDonnel2023} 
allemaal significant sneller zijn dan bestaande applicaties.
Een ander verschil tussen Node.js en Bun is de ingebouwde support voor TypeScript en JSX. 
Terwijl bij Node.js je hiervoor aparte packages nodig hebt, 
zal bij Bun de transpiler deze bestanden automatisch converteren naar vanilla Javascript.

Doordat Bun redelijk nieuw is, zijn er nog maar weinig onderzoeken over gedaan.
Één van deze onderzoeken werd uitgevoerd door ~\textcite{Feroj2023}.
Hierbij werd de performantie tussen Node.js en Bun vergeleken op basis van verschillende performantie attributen. 
Deze omvatten geheugengebruik, antwoordtijd en de algemene uitvoeringstijd. 
Voor het testen van netwerk verzoeken werd bij beiden gebruik gemaakt van Bombardier. Hierbij werden in 3 aparte scenarios, 
10 miljoen gemaakt met eerst 10 gelijktijdige connecties, dan 100 gelijktijdige connecties en
uiteindelijk 500 gelijktijdige connecties. Hierbij kon de onderzoeker de performantie van de servers evalueren 
aan de hand van responstijd en doorvoer. Aanvullend werden ook de geheugengebruik pieken bepaald.
Daarnaast werd ook getest hoe beide runtimes een alleenstaand script afhandelen. 
Dit werd gedaan aan de hand van Hyperfine, een command-line process benchmark hulpmiddel. 
Hierbij werd de executie tijd gemeten in zowel Bun als Node.js voor het berekenen van Fibonacci nummers.
Het eerste resultaat toont het verschil in geheugengebruik tussen Bun en Node.js. 
Hierbij heeft Bun consistent een lager geheugengebruik tegenover Node.js en toont het aan dat Bun een beter geheugenbeheer heeft.
De onderzoeker merkt op dat de oorzaak hiervan ligt bij Bun's gebruik van Zig, 
een programmeertaal gekend voor zijn effectiviteit en geheugenbeheer. 
Ook op vlak van executie tijd, responstijd en doorvoer presteerde Bun consistent beter dan Node.js. 
Deze resultaten tonen aan dat Bun algemeen beter presteert in zowel het afhandelen van netwerk verzoeken 
als het uitvoeren van computationele taken.
De onderzoeker merkt echter ook op dat de keuze van een runtime niet alleen kan bepaald worden op basis van performantie. 
Andere factoren, die hier niet getest zijn, zoals beveiling, stabiliteit en onderhoudbaarheid dragen ook bij tot de keuze. 
Ook waren de geteste programma's redelijk simpel waardoor de resultaten mogelijks niet accuraat zijn voor complexere omgevingen.
Verder onderzoek zou ook baat hebben om rekening te houden met verschillende omstandigen, 
zoals CPU-gebonden en I/O-gebonden processen.

%---------- Methodologie ------------------------------------------------------
\section{Methodologie}%
\label{sec:methodologie}

Hier beschrijf je hoe je van plan bent het onderzoek te voeren. 
Welke onderzoekstechniek ga je toepassen om elk van je onderzoeksvragen te beantwoorden? 
Gebruik je hiervoor literatuurstudie, interviews met belanghebbenden (bv.~voor requirements-analyse),
 experimenten, simulaties, vergelijkende studie, risico-analyse, PoC, \ldots?

Valt je onderwerp onder één van de typische soorten bachelorproeven die besproken zijn in de lessen Research Methods 
(bv.\ vergelijkende studie of risico-analyse)? Zorg er dan ook voor dat we duidelijk de verschillende stappen 
terug vinden die we verwachten in dit soort onderzoek!

Vermijd onderzoekstechnieken die geen objectieve, meetbare resultaten kunnen opleveren. Enquêtes,
 bijvoorbeeld, zijn voor een bachelorproef informatica meestal \textbf{niet geschikt}. 
De antwoorden zijn eerder meningen dan feiten en in de praktijk blijkt het ook bijzonder moeilijk om 
voldoende respondenten te vinden. Studenten die een enquête willen voeren,
 hebben meestal ook geen goede definitie van de populatie,
 waardoor ook niet kan aangetoond worden dat eventuele resultaten representatief zijn.

Uit dit onderdeel moet duidelijk naar voor komen dat je bachelorproef ook technisch voldoen\-de diepgang zal bevatten.
Het zou niet kloppen als een bachelorproef informatica ook door bv.\ een student marketing zou kunnen uitgevoerd worden.

Je beschrijft ook al welke tools (hardware, software, diensten, \ldots) je denkt hiervoor te gebruiken of te ontwikkelen.

Probeer ook een tijdschatting te maken. Hoe lang zal je met elke fase van je onderzoek bezig zijn en wat zijn de concrete
 \emph{deliverables} 
in elke fase?

Het onderzoek bevat 5 fasen.
De eerste fase is het beschrijven van Node.js en Bun. 
Dit wordt gedaan aan de hand van een literatuurstudie van wetenschappelijke artikels en boeken. 
De geschatte duurtijd van dit proces is 2 weken.

De tweede fase bestaat uit het verzamelen van de de criteria die zal getest worden bij beide omgevingen. 
Dit gebeurt in samenspraak met de co-promotor. Hierbij worden deze criteria geordend volgens belang. 
De verzameling van deze criteria duurt 1 week.

In de derde fase wordt een proof-of-concept gemaakt voor zowel Node.js als Bun. 
Hierbij wordt een applicatie ontwikkeld waarbij een gebruiker een recensie kan creëren over een bepaald onderwerp.
Voor deze ontwikkeling is een geschatte duurtijd van 4 weken voorzien.

In de vierde fase worden te testen uitgevoerd op de proof-of-concepts. 
Hierbij zal gebruik gemaakt worden van benchmark tools Hyperfine en Bombardier om de performantie te testen.
Voor het visualiseren van de metingen zal Seaborn worden gebruikt.
Dit proces neemt 4 weken in beslag.

De laatste fase bevat een conclusie over de vergelijking. 
Hierbij wordt een aanbeveling gegeven op basis van de metingen en testen.
Dit neemt 1 week in beslag
%---------- Verwachte resultaten ----------------------------------------------
\section{Verwacht resultaat, conclusie}%
\label{sec:verwachte_resultaten}

Hier beschrijf je welke resultaten je verwacht. Als je metingen en simulaties uitvoert, 
kan je hier al mock-ups maken van de grafieken samen met de verwachte conclusies. 
Benoem zeker al je assen en de onderdelen van de grafiek die je gaat gebruiken. 
Dit zorgt ervoor dat je concreet weet welk soort data je moet verzamelen en hoe je die moet meten.

Wat heeft de doelgroep van je onderzoek aan het resultaat? Op welke manier zorgt jouw bachelorproef voor een meerwaarde?

Hier beschrijf je wat je verwacht uit je onderzoek, met de motivatie waarom.
Het is \textbf{niet} erg indien uit je onderzoek andere resultaten en conclusies vloeien dan dat je hier beschrijft: 
het is dan juist interessant om te onderzoeken waarom jouw hypothesen niet overeenkomen met de resultaten.

